function [ dlXC, Q, dlZC ] = calcLatentComponents( self, args, args2 )
    % Calculate the funtional components 
    % introducing the option to convert to single
    arguments
        self                AEModel
        args.dlZ            dlarray
        args.dlXB           cell
        args.dlXC           dlarray
        args.mode           char ...
                            {mustBeMember(args.mode, ...
                            {'Full', 'InputOnly', 'OutputOnly'} )} = 'Full' 
        args.maxObs         double {mustBeInteger} = 500
        args.sampling       char ...
                            {mustBeMember(args.sampling, ...
                            {'Regular', 'Component'} )} = 'Component' 
        args.nSample        double {mustBeInteger} = 20
        args2.convert       logical = false
    end

    % calculate the response of the specified type
    argsCell = namedargs2cell( args );
    switch self.ComponentType
        case 'ALE'
            [dlXC, Q, dlZC] = calcALE( self, argsCell{:} );
        case {'PDP', 'FPC'}
            [dlXC, Q, dlZC] = calcPDP( self, argsCell{:} );
        case 'AEC'
            [dlXC, Q] = calcAEC( self, argsCell{:} );
            dlZC = [];
        otherwise
            dlXC = [];
            Q = [];
            dlZC = [];
    end

    % put XC into the appropriate structure
    % Points, Samples, Components, Channels
    nSamples = size(dlXC, 2);

    % extract the mean curve based on Z
    XMean = dlXC( :, ceil(nSamples/2), :, : );
    
    switch self.ComponentCentering
        case 'Z'
            % centre about the curve generated by mean Z
            dlXC = dlXC - XMean;
        case 'X'
            % centre about the mean generated curve
            dlXC = dlXC - mean( dlXC, length(size(dlXC)) );
    end

    if args2.convert
        dlXC = double( extractdata( dlXC ) );
        if ~isempty( dlZC )
            dlZC = double( extractdata( dlZC ) );
        end
    end

end
